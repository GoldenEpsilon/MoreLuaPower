/*
 *  More Lua Power, started by Golden Epsilon
 *  Tons of stuff added by Sunreal, Shenanigans, Lea, and DecoyDoge
 *  Other Contributors: stephanreiken, tongo
 *  Workshop URL: https://steamcommunity.com/sharedfiles/filedetails/?id=2066319533
 *  GitHub Page: https://github.com/GoldenEpsilon/MoreLuaPower
 *
 *  Please do not include the DLL in your mods directly:
 *      Ask people to download the workshop version instead.
 *      
 *  That said, if there's something you want to modify from the code to make your own harmony mod, feel free!
 *  I am also open to help; If you have something you want to add in here, just let me know/add it in yourself! You will be credited.
*/

Welcome to the API! I'm going to try and organize this as much as possible, but there is only so much I can do.
    If you have suggestions to improve this, let me know! I'm [Golden Epsilon#8656] on discord.

I'm also going to have vanilla features in here as well, 
    so that if you know how modding works already you can relate what I modified, 
    and so if you don't know you can learn all the features at once.

Quick note: The features in here are in order of when they were added, so for new features scroll to the bottom of each category.
	
Table of Contents:
	[MISC FEATURES]
	[NEW MECHANICS]
	[NEW FTRIGGERS]
	[LUA FUNCTIONS]
	[CALLED LUA FUNCTIONS]
	[GLOBAL LUA VARIABLES]
	[CUSTOM DATA TYPES]
	[CUSTOM FILE TYPES]
	[ACCESSIBLE TYPES]
	[ORGANIZATION]
	[PETS]
	[BOSSES]

[MISC FEATURES]
	Subfolder Loading
		//Files inside folders inside mod folders will now be loaded as part of the mod.
		// There is an exception with folders named Disabled, for organization purposes,
		// but if the mod is named disabled the directory itself still loads anyway. (it won't load subdirectories, however)
		// NOTE: naming the folder disabled works with any capitalization.

	Custom Lua Effects
		//This is a recreation of https://steamcommunity.com/sharedfiles/filedetails/?id=2063268758, with a bit more flair
		// In the XML you can use the keyword Lua instead of something else like Frost, and it will call the function you specify
		// As an example, you could do <OnHit value="ExampleFunction">Lua</OnHit> and it would run the function ExampleFunction()

[NEW MECHANICS]	

	Program Advance    //NEEDS A REWRITE, DO NOT USE YET
		//Program advance is a mechanic from MMBN where you combine multiple chips into one powerful chip.
		//Spells with the ProgramAdvance param will be parsed otherwise, do a normal spell cast
		// ProgramAdvanceLinkWith is the name of the spell in the other slot needed to trigger the Advance Spell - use commas to separate spells
		// CostAdvancedMana is a boolean that determins if the Advance Spell drains mana
		// ConsumeAfterAdvance is a boolean that consumes the chip after the Advance Spell
		// AdvanceSpell is spell that ends up being casted
		//Example: <Params ProgramAdvance="true" ProgramAdvanceLinkWith="Thunder" CostAdvancedMana="false" ConsumeAfterAdvance="true" AdvanceSpell="StormThunder"></Params>
		//Example: <Params ProgramAdvance="true" ProgramAdvanceLinkWith="MiniThunder" CostAdvancedMana="false" ConsumeAfterAdvance="true" AdvanceSpell="StormThunder"></Params>
		//Example: <Params ProgramAdvance="true" ProgramAdvanceLinkWith="Frostbolt,IceNeedle" CostAdvancedMana="true" ConsumeAfterAdvance="false" AdvanceSpell="Tundra"></Params>
		//			NOTE: This last example activates on EITHER Frostbolt or IceNeedle

	Multicast
		//Multicast is a mechanic that allows you to make spells that dont discard after the first use!
		//Spells with the DontDiscard param will be parsed otherwise, do a normal spell cast
		//ShotsRemaining is a number that keeps track of how many casts you have left
		//MaxShots is self-explanatory
		//ManaCost is either "Start", "End", or "All", Defaulting to "All".
		//  If it is set to "Start" the mana cost will only be used the first cast,
		//  if it is set to "End" the mana cost will only be used the last cast,
		//  and if it is set to "All" the mana cost will be used for all casts.
		//Note: ManaCost does not affect anything if you don't have ShotsRemaining
		//Example: <Params DontDiscard="true" ShotsRemaining="5" MaxShots="5" ManaCost="Start"></Params>

	Kicker Cast
		//A kicker cast is a spell that behaves differently depending on how much mana the player has. Generally looks like this. Cast mini thunder for zero mana,
		//but if the player has 3 mana cast thunderstorm instead.
		//Example: <Params KickerCast="true" KickerManaCost="4" KickerSpell="StormThunder"></Params>
		//Kicker cast also supports multiple kickers
		//Examole: <Params KickerCast="true" KickerManaCost="1,4" KickerSpell="Thunder,StormThunder"></Params>

	Pet Additions
		//Go to the [PETS] section for more info.

[NEW FTRIGGERS]

(quick note: these are only lightly tested, if something doesn't work as you expect feel free to ask me about it)
	OnSave				//When the game is saved, trigger
	OnLoad				//When the game is loaded, trigger (NOTE: This doesn't work on artifacts, use it with custom hooks if you do.)
	OnChooseArtifact	//When any artifact is chosen, trigger
	OnRemoveArtifact	//When any artifact is removed, trigger
	OnChoosePact		//When any pact is chosen, trigger
	OnRemovePact		//When any pact is removed, trigger
	OnUpgrade			//When any artifact or spell is upgraded, trigger
	OnChoose			//When any artifact or spell is chosen to add to deck, trigger
	OnRemove			//When any artifact or spell is removed, trigger
	OnChooseThis		//When this artifact (or spell? Needs testing) is chosen to add to deck, trigger for this item
	OnRemoveThis		//When this artifact (or spell? Needs testing) is removed, trigger for this item
	OnTaunt				//When a player taunts, trigger
	PreMove				//unimplemented
	PreHit				//unimplemented
	OnOwnedPetDeath		//unimplemented
	OnPetDeath			//unimplemented
	OnLoop				//unimplemented

[LUA FUNCTIONS]

MoreLuaPower:

	void MakeSprite			(string {path}, PATH, string {name})
		//Takes the path to the image you want to turn into a sprite
		// compared to your mod's base directory, the PATH global variable,
		// and a name for the sprite. Keep track of that name, because
		// that's how you use the |Sprite| later. More info in [custom data types].
		// this function MUST be called in the first frame of Init() to be used at all.

	Sprite GetSprite		(|Sprite| {sprite})
		//Turns the string-based sprite into a unity sprite - 
		// I haven't had much luck messing with sprites directly in lua, however.
		// The main purpose of this function for now is that
		// it returns nil when the sprite asked for either doesn't exist
		// or hasn't loaded in yet.
	
	void NewEffect			(string {name}, |Sprite| {sprite} = "")
		//Creates a new |StatusEffect| named {name}, using {sprite} as the icon if given.

	void AddEffect			(Being {being}, |StatusEffect| {effect}, float {duration} = 0, float {amount} = 0)
		//Adds {effect} to {being}.
		// If {duration} is 0, the effect duration is infinite.
		// Keep in mind when using this for vanilla effects that they don't always allow arbitrary {amount}s:
		// As an example, Fragile cannot apply less than one stack.

	bool GetEffect			(Being {being}, |StatusEffect| {effect})
		//Checks to see if {being} has {effect}, and returns true or false.
		// If the effect does not exist, returns false and logs that the effect does not exist in the chat.

	float GetEffectAmount		(Being {being}, |StatusEffect| {effect})
		//Checks to see if {being} has {effect}, and returns the amount of the effect if so.
		// If the effect does not exist, returns 0 and logs that the effect does not exist in the chat.

	void RemoveEffect		(Being {being}, |StatusEffect| {effect})
		//Removes {effect} from {being}

	bool EffectExists		(string {effect})
		//Checks to see if {effect} exists.
		// In other words, it checks if NewEffect has been run for {effect}
		
	Brand MakeBrand			(string {name}, string {description} = null)
		//Adds a brand called {name} to the game.
		// MUST be called in either Init or from outside of any functions,
		// because to work this must run the first frame that lua files are loaded.
		// ALSO, if called from Init you cannot have any wait functions before calling this function.
		// description is optional, but recommended.
		// The recommendation for creating a brand is to use a variation of this in Init:

		// MakeSprite("ExampleSprite.png", PATH, "ExampleSprite");
		// MakeBrand("ExampleBrand");
		// while (GetSprite("ExampleSprite") == null) do
        //     WaitForFrames(1);
        // end
		// SetBrandImage("ExampleBrand", "ExampleSprite");
		
	Brand GetBrand			(Brand {brand})
		//Returns the name of {brand} as a string

	void SetBrandImage		(string {name}, string {sprite}, string {BGSprite} = null)
		//Sets the image(s) of the Brand named {name}.
		// Must be called after all sprites to be used in the function are loaded.
		// The recommendation for creating a brand is to use a variation of this in Init:

		// MakeSprite("ExampleSprite.png", PATH, "ExampleSprite");
		// MakeBrand("ExampleBrand");
		// while (GetSprite("ExampleSprite") == null) do
        //     WaitForFrames(1);
        // end
		// SetBrandImage("ExampleBrand", "ExampleSprite");

	void ParticleEffect		(Being {being}, |ParticleSystem| {system})
		//Creates and runs a particle effect attached to the Being you pass.
		// More info on |ParticleSystem| is in [custom data types].

	void PlayCustomSound			(Being {being}, |Sound| {sound})
		//Plays the sound specified.
		// If the sound does not exist, it logs that the effect does not exist in the chat.

	void PlayCustomMusic	(|Music| {music})
		//plays the specified sound as music. 
		// What you put here is the same string as you put in for {AudioName} for MakeCustomMusic.
		// Recommended for stuff like bosses

	void PlayCustomMusicIntroLoop	(|Music| {music}, float {IntroBoundry}, float {EndBoundry})
		//plays the specified sound as music with looping. 
		// What you put here is the same string as you put in for {AudioName} for MakeCustomMusic.
		// You'd have to check with Sunreal, but I believe the music goes back to IntroBoundry whenever it reaches EndBoundry

	void SetVariable		(Being {being}, string {variableName}, string {variable})
		//Sets the Custom Variable {variableName} to {variable} for {being}, adding it if it doesn't exist.

	string GetVariable		(Being {being}, string {variableName})
		//Gets the Custom Variable {variableName} from {being}, returning "Variable Not Set" if it doesn't exist.

	void AddHook			(FTrigger {trigger}, string {functionName}, being {attachedBeing} = null)
		//Adds the function {functionName} as a hook, which means that it will be activated every time {trigger} is activated
		// You can attach it to any being, by default it'll attach to a player.

	void AddLangTerm		(string {termName}, string {translation}, string {language} = "English")
		//Adds a term to the language dictionary, optionally letting you choose a language other than english.
		// Mainly used behind the scenes for adding brands right now, but also works for changing whatever 
		// text you want if you look into the code.

	bool GetCustomInput		(KeyCode {code})
		//Checks whether the key {code} is pressed

	bool EnableDeveloperTools()
		//Turns on the dev console, returning whether it just opened or closed
		// As of right now this function is redundant because you can press ` to open the console when MoreLuaPower is loaded
		
	Player GetPlayer		()
		//Simply returns the current player.
		// Meant to be used in Update, GameUpdate, and other similar functions.

	void PrintDev			(string {str})
		//Prints a message to the dev console

	void RunDev				(string {str})
		//Runs a command from the dev console
	
	void AddCustomMusic		(string {AudioName}, float {volume} = 1, float {startTime} = 0)
		//Adds the file specified by {AudioName} as |Music| that you can call with other functions.

	bool AudioExists		(string {AudioName})
		//returns false while {AudioName} doesn't exist or is loading

	void AddMusicHook		(|Music| {music}, string {zoneBgName}, string {type})
		//Sets the zone's music to {music}
		// The valid inputs for {type} are "Idle" and "Battle", both self-explanatory.
		// {music} is the same string as you put in for {AudioName} for MakeCustomMusic.

	void AddZoneIcon		(|Sprite| {spriteName}, string {dotName})
		//Sets the zone {dotName}'s icon to {spriteName}, I believe (you use the name in zones.xml)
		// ...ask @Sunreal#3392 for clarification if you need it.

	void AddUpgrade			(string {name}, string {abbreviation}, string {description}, |Function| {check}, |Function| {effect})
		//Adds the upgrade to the game, using the inputs to help - |Function| is a string with the name of the function. Use something unique.
		// {name} needs to be unique - I don't believe it shows up anywhere, so you could prepend your mod name or something
		// {abbreviation} is typically a single letter; OSFE takes up a lot of the options, though, so if you need to feel free to change it up a bit with two letters or something.
		// {description} gets automatically surrounded by parentheses, so you don't need to do that manually. Length should be as short as you can.
		// {check} is a function that takes a SpellObject as an input and returns a boolean, and it's used to see if the upgrade can be applied to the spell. 
		//		If it fails this check, your upgrade will not show up.
		// {effect} is also a function that takes a SpellObject as an input and returns the same SpellObject as an output.
		//		This is where you actually add your modifications.
		//		You should be able to use it to run custom code when it's cast, if you can't figure it out ping me and I can work it out with you.

	void AddDropCheck		(string {name}, |Function| {check})
		//Adds a drop check for the given item - for example, you could make the CustomFoo artifact only drop when you have the CustomBar spell on you.
		// {name} is the name of the item to add the check to
		// {check} is the function that you want to use (it needs to return true or false, false to have the item not show up)

	void AddXMLToSpell(SpellObject {spellObj}, string {XML})
		//Adds a line of XML to the SpellObject
		// Meant to be used for upgrading spells
		// Does not need tags like {Spells} or {Spell}, just put the tags that you would want in the spell directly like {OnHit>Flame{/OnHit>

	void ApplyRandomUpgrade(SpellObject {spellObj}, [List] {denyList})
		// Applies a random valid upgrade to the spell, as if it were randomly generating an one using an Upgrader.
		// Since this uses the same mechanism as the vanilla game, it can apply modded upgrades as well, using whatever checks to see if the spell can be applied.
		// {spellObj} is the spell to upgrade
		// {denyList} is any list of Enhancements to not add (can be empty)
		// Ex: ApplyRandomUpgrade(mySpell, {}) or ApplyRandomUpgrade(mySpell, {Enhancement.Frost, Enhancement.Fragile})

	void MakeZoneGenocideLenient(string {zoneName})
		//Makes the zone not matter for the game's route (pacifist, neutral, genocide)
		// Meant for older custom bosses before sparing was figured out, or for zones that you don't want to affect the ending

	int GetBossTier(Being {being})
		// Returns the boss' current tier, or if the being isn't a boss, what the tier for a boss would currently be.
		// Useful for scripting tier-based boss attack patterns in lua
		// Ex: local tier = GetBossTier(item.being)

	void Log(string {message}, LogLevel {logLevel})
		//Writes {message} to the debug log and/or the console, depending on {logLevel}.
		// Meant to be a flexible replacement for print() that prints to the console as well

	void ChangeFileLogLevel(LogLevel {logLevel})
		//Sets what logs get written to the debug log ({logLevel} or higher)
		// Great for debugging errors that aren't obviously failing
		
	void ChangeConsoleLogLevel(LogLevel {logLevel})
		//Sets what logs get written to the console ({logLevel} or higher)
		// Great for debugging errors that aren't obviously failing
		
	void AddTriggerTooltip(string {trigger}, string {name}, string {tooltip})
		//Adds a tooltip for the given FTrigger for hovering over spells/artifacts.
		// {trigger} is the name of the FTrigger internally, 
		// {name} should be the name to be used in the popup, {tooltip} is the description.
		
	void AddEffectTooltip(string {effect}, string {name}, string {tooltip})
		//Adds a tooltip for the given Effect for hovering over spells/artifacts.
		//Make sure to call NewEffect() before this.
		//For use with Lua XML effects such as <OnHit value="MyEffect">Lua</OnHit>
		// {effect} is the name of the Lua function in the value attribute ("MyEffect", in this example), 
		// {name} should be the name to be used in the popup, {tooltip} is the description.

	void OverrideAnimator(Being {being}, string {animName})
		//Overrides the being's animator with the one for {animName}
		// Allows base-game animators to be swapped for modded ones and vice versa

	void AddBar(string {name}, string {barPosition}, Being {being}, float {current}, float {max}, int {segments}, int {colorR}, int {colorG}, int {colorB}, Sprite {sprite}, bool {showValue}, bool {showMax})
		// Creates a bar on the screen with the given parameters. Remember to use GetSprite(), as this line requires the actual sprite and not just its name.
		// Bar positions:
		// TopLeft - Places the bar at the top of the screen, on the left side
		// TopRight - Places the bar at the top of the screen, on the right side
		// Left - Places the bar with a vertical orientation on the left side of the screen by the cardtridge queue
		// OverMana - Places the bar above the mana bar
		// UnderMana - Places the bar below the mana bar
		// BesideMana - Places the bar to the right of the mana bar 
		// OverBeing - Places the bar over the being's head
		// UnderBeing - Places the bar under the being's HP display
		// BesideBeing - Places the bar with a vertical orientation, attached to a being at its side

	void UpdateBar(string {name}, float {current}, float {max})
		// Updates the bar named {name} with the given values. Put this in your lua wherever the value of the bar is manipulated to visually update it.

	void ChangeBarColor(string {name}, int {colorR}, int {colorG}, int {colorB})
		// Sets the color of the bar using RGB 256 values.

	void ChangeBarSprite(string {name}, Sprite {sprite})
		// Updates the bar's sprite. Use in conjunction with GetSprite()

	void ChangeBarAttributes(string {name}, bool {showValue}, bool {showMax}, int {segments})
		// Allows you to change the segmentation of the bar and whether or not the value / max value are shown

	void HideBar(string {name})
		// Hides a bar named {name}

	void ShowBar(string {name})
		// Shows a hidden bar

	void LoadCutscene(string {path}, PATH, string {name})
		//Takes the path for a video and loads it under {name}
		// The basics, like PATH, are the same as MakeSprite.
		// To be used with PlayCutscene.
		// {name} is what you use in the |Video| parameter to access the loaded video.
		// Must be called the first frame of Init().

    void PlayCutscene(|Video| clip, bool {pausemusic} = false, bool {clearprojectiles} = false, bool {stopenemies} = false, int {endlag} = 1)
		//Takes the name of a loaded video and plays it. 
		// set {pausemusic} to true to pause the current song, false to not pause it.
		// {clearprojectiles} makes projectiles disappear except for heals and sera on the ground
		// {stopenemies} anchors enemies and stops their routines so they don't act until the cutscene ends. 
		//  Doesn't affect timers, such as from Hostages and chests.
		// {endlag} is how many seconds before the player regains control (and enemies if {stopenemies} is true)
		//  after the end of the cutscene.
	
    void PlayCutsceneURL(string {URL}, bool {pausemusic} = false, bool {clearprojectiles} = false, bool {stopenemies} = false, int {endlag} = 1)
		//Same as PlayCutscene, just with a string input for the URL so that you
		// can link to online content. It doesn't work with Youtube, though.

	void SetCheatcode(string {characterName}, string {buttonName}, string {functionName})
		//Lets you do "Cheatcodes" on the character select screen.
		//For example, if you call this in init:
		//CustomCheatcodes.SetCheatcode("QueenAurora", "Weapon", "QPQueenGetFullAuroraDeck");
		//When the player select a character the game checks if the player is holding the weapon button, 
		//if the being is Queen aurora and if so it calls the QPQueenGetFullAuroraDeck lua function

	void CharSetupTaunt(string {name})
		//Lets a modded character and/or skin taunt
		//Call this function in Init with {name} as the name of the character/skin and it will be able to taunt ingame.

	void GetFTrigger(string {name})
		//Takes the name of an FTrigger and returns the FTrigger object
		//This is for custom FTriggers, because of how MoonSharp works.
		//Use this instead of trying to do FTrigger.OnRemove or equivalent. (for specifically custom FTriggers)

	void AddCustomAchievement	(string {name}, |Sprite| {sprite}, string {description}, bool {hidden})
		// {name} is the name the Achievement, i.e "Absolute Zero", "Bravely Ascetic", or "Pacifist"
		// {sprite} refers to a |Sprite| as defined by Make/GetSprite. Achievement Icons are 156x156 and lack a border like spell icon pngs.
		// {description} is the description of the Custom Achievement. i.e. "Absolute Zero" has a {description} of "Have 0 Max Mana"
		// {hidden} defaults to false. if set to true, while locked, CustomAchievement's Description will be "??????"
		// Call this in an Init after any relevant Make/GetSprite are called.

	void UnlockCustomAchievement	(string {name}, int {percentUnlocked} = 100)
		// Sets the Custom Achievement {name} added in AddCustomAchievement to Unlocked if {percentUnlocked} = 100.
		// Checks to make sure {name} is an achievement that was generated by AddCustomAchievement before doing so
		// On First call, will set a Toast for achievement Unlocked.
		// if {percentUnlocked} = 0, will re-lock the Achievement. (May toast repeatedly)
		// Call in a Function in the same Lua folder as the AddCustomAchievement.
		// Example: 	function UnlockerShoo (item)
    	//						UnlockCustomAchievement("Shoo Out The Clowns")
		//				end


Lua-based:

	PetBuffArtifactFunction(item, target, status, amount, duration, extra)		
		// Item needs to be a reference to the item that triggered this effect. 
		// Look at the [PETS] section for more info

	PetBuffArtifactPetIDFunction(item, petid, status, amount, duration, extra) 	
		// Targeting by PetID runs this function instead
		// Look at the [PETS] section for more info


[CALLED LUA FUNCTIONS]
//note: these do not come with an object as an input, you will want to use S.I.whatever to access objects.

	Init:
	//When put into a file will be called only once.
	// This is for loading sprites and such.

	Awake:
	//When put into a file will be called whenever the game loads/reloads lua mods.
	// This is for setting global variables and such.

	Update:
	//Is called every frame, including on menus and when time's stopped.

	GameUpdate:
	//Is called every physics update, does not run on certain menus intentionally like the main menu and the game over menu. Meant for updating during gameplay.


[GLOBAL LUA VARIABLES]

MoreLuaPower:
    Time:				Time			//I HAVEN'T CHECKED IF THIS WORKS YET
    TimeScale:			Time.timeScale
    DeltaTime:			Time.deltaTime
	S:					S				//NOTE: access correctly with S.I
	PATH:				the path to your mod's directory
	And a bunch of other enums that I'm not gonna list for now because there are too many to keep track of XD

Vanilla:
	State:				State
	Status:				Status
	FireLoop:			FireLoop
	FTrigger:			FTrigger
	Direction:			Direction
	ItemType:			ItemType
	Target:				Target
	Block:				Block
	GunPointSetting:	GunPointSetting
	BC:					BC


[CUSTOM DATA TYPES]	
//note: these are not actual data types, I just name it that because you need to treat them in special ways. 
// Custom data types are differentiated in the API by ||, so for example there are |Sprite|s and |Status|es

	|Sprite|
		//You need to load these manually using MakeSprite, and then you use them by passing a string that is the same as the name.
		//NOTE: You MUST leave at least a few frames between MakeSprite and using the new sprite. 
		//		I personally recommend running all of your MakeSprites in Init.lua (don't put your code in a function, and it runs on mod load)

	|Sound|
		//These are loaded automatically just by being in your mod folder, you pass them in by using a string that is the same as its name.
		//Also works with mp3 files.

	|StatusEffect|
		//You create this by running NewEffect, and check to see if it exists with EffectExists. Pass it in with a string of the name.
		//Also works with vanilla effects, so you can pass in "Shield" to AddEffect to give the Being shields.

	|Material|
		//As of right now this is only used internally for particle systems.

	|ParticleSystem|
		//This is just a table that looks for specific parameters and values.
		//USED IN:
		//	
		//The values shown here are the default values, 
		//if your ParticleSystem table doesn't have a certain parameter it defaults to these.
        { sprite = "Normal" },				//sprite name from MakeSprite
        { xOff = "0" },
        { yOff = "0" },
        { zOff = "0" },
        { loop = "false" },					//true, True, TRUE, 1, false, False, FALSE, 0
        { duration = "0.15" },
        { startDelay = "0" },
        { sstartLifetime = "0.5" },
        { startSpeed = "500" },
        { startSize = "2" },
        { startSizeMin = "-1" },			//These overwrite startSize when both are a positive number
        { startSizeMax = "-1" },			//This is the same as changing size over time.
        { startRotation = "0" },			//Degrees
        { startColor = "#FFF" },			//hex color (you can also pass alpha in the hex color)
        { startColorMin = "" },				//These overwrite startColor when both are a valid color.
        { startColorMax = "" },				//This is the same as changing color over time.
        { gravityModifier = "0" },
        { simulationSpace = "Local" },		//Local, Global
        { emissionRate = "10" },
        { burstCount = "1" },				//Integers only
        { shape = "Sphere" },				//Sphere, Hemisphere, Cone, Donut, Box, Circle, Edge, Rectangle //TODO

	|Function|
		//A string that is the name of the function you want to call. THIS SHOULD BE UNIQUE.
		//If another mod has a function with the same name, it may cause problems, 
		//so I recommend making a prefix (for example, for More Powerful Lua it'd be "MPLFoo")


[CUSTOM FILE TYPES]

MoreLuaPower lets you add custom file loading to your mod. 
Adding a CustomFileTypes.xml to your mod will allow it to handle any file under the specification you give. 
The loading of MP3 files is done using this functionality. Use that as a template.
Ask in the modding discord for help on this one. @Shenanigans specifically.

//Also loads subfolders of mods after all mods' main folders are loaded.


[ACCESSIBLE TYPES]

MoreLuaPower:
	Rewired.Player							//This is used for checking button presses
	S
    Run
    SpellListCard
	ListCard
    StatusEffect
    HeroSelectCtrl
    AnimatorOverrideController
    Sprite
    Check
	Shape
	Location
	ArcType
	KeyCode
	ItemObject
	AnimationOverrider
	Ally
	Cpu

Vanilla:
    Transform
	Cardtridge
	Vector3
	List<Being>
	List<Cpu>
	Animator
	Quaternion
	Rigidbody2D
	BoxCollider2D
	Time
	State
	Status
	Direction
	FTrigger
	ItemType
	GunPointSetting
	TalkBox
	RunCtrl
	DuelDisk
	EffectApp
	Target
	StatusApp
	AmountApp
	DeckScreen
	HeroProfile
	FireLoop
	Player
	List<Tile>
	List<TileApp>
	List<SpellObject>
	List<string>
	ShopCtrl
	Block
	BattleGrid
	CastSlot
	SpellObject
	ArtifactObject
	Spell
	Artifact
	Tile
	Projectile
	ProjectileFactory
	Moveable
	BeingObject
	Enemy
	Structure
	BC
	DeckCtrl
	PostCtrl
	ItemManager
	TileApp
	Health
	StatsScreen
	TI
	Being


[ORGANIZATION]
	//note: this section is for looking through the c# source code.
	//NOTE: this hasn't been updated in a while. Everything should still be accurate, there is just more than is mentioned here.

	CustomData.cs
		LuaPowerData
			|Sprite|			(sprites)
			|StatusEffect|		(statuses)
			|Material|			(materials)
			|ParticleSystem|	(DPS)

	CustomParticles.cs
		LuaPowerParticles
			void ParticleEffect(Being being, Dictionary<string, string> system)

	CustomSound.cs
		MoreLuaPower_SoundLoader
			Patch of ModCtrl._InstallTheseMods
				void Prefix(ref ModCtrl __instance, FileInfo[] fileInfo, string modsDir)
					//loads all sounds from the directory. Calls PowerMonoBehavior.LoadSound()
					//Adds PowerMonoBehavior to S.I's GameObject if it is not there already
		LuaPowerSound
			void PlayCustomSound(Being being, string sound)

	CustomSprites.cs
		LuaPowerSprites
			void MakeSprite(string image, string PATH, string name)
				//loads the sound that is requested. Calls PowerMonoBehavior.LoadSprite()
				//Adds PowerMonoBehavior to S.I's GameObject if it is not there already

	CustomStatusEffects.cs
		MoreLuaPower_CustomStatusTranspiler
			Transpiler for StatusEffect.Set
				Explanation is in file
		MoreLuaPower_CustomStatusEffects
			Patch of StatusEffect.Set
				void Postfix(Being being, Status statusType, StatusEffect __instance, Image ___icon, Image ___iconBackground)
		LuaPowerStatus
			void Setup()
				//adds vanilla status effects to the list of status effects
			void NewEffect(string effect, string sprite)
			bool EffectExists(string effect)
			void AddEffect(Being being, string effect, float duration = 0, float amount = 0)
			bool GetEffect(Being being, string effect)
			float GetEffectAmount(Being being, string effect)
			void RemoveEffect(Being being, string effect)

	GlobalLuaFunctions.cs
		MoreLuaPower_GlobalLuaFunctions
			Patch of new EffectActions(string)
				void Postfix()
					//adds all of the global lua functions

	GlobalLuaTypes.cs
		MoreLuaPower_GlobalLuaTypes
			Patch of new EffectActions(string)
				void Postfix()
					//adds all of the global lua types

	GlobalLuaVariables.cs
		MoreLuaPower_GlobalLuaTypes
			Patch of new EffectActions(string)
				void Postfix()
					//adds all of the global lua variables except for PATH
		MoreLuaPower_PATHVariable
			Patch of EffectActions.AddScript
				void Prefix(string scriptPath, Script ___myLuaScript)
					//adds the PATH global variable

	MoreLuaPower.cs
		MoreLuaPower
			Patch of new EffectActions(string)
				void Postfix()
					//calls LuaPowerStatus.Setup()
		PowerHelpers
			//any in-development features that don't have their own file yet can go here

	PowerMonoBehavior.cs
		PowerMonoBehavior
			IEnumerator LoadSprite(string url, Action<Texture2D> response)
			IEnumerator LoadSound(FileInfo file, AudioType audioType, Action<AudioClip> response)

	ProgramAdvance.cs
		MoreLuaPower_ProgramAdvance
			Patch of Player.CastSpell
				bool Prefix(ref Player __instance, int slotNum, ref int manaOverride, bool consumeOverride)
				//adds the ProgramAdvance mechanic
	Multicast.cs
		MoreLuaPower_Multicast
			Patch of Player.CastSpell
				bool Prefix(ref Player __instance, int slotNum, ref int manaOverride, bool consumeOverride)
				//adds the Multicast mechanic
[PETS]
	PetBuff for MoreLuaPower by stephanreiken

	If you want your spell to buff pets, add this Action to your spell.
	<Action>PetBuffSpell</Action>

	Add these Paramaters to the spell in order to control what PetBuffSpell does.

	PetBuffInBattleOnly="false" //Only include this if you set it to false, False, or FALSE as true is the default behavior. Generally don't change this as it would allow you to add buffs, shields, or healing to your pets outside of combat.

	PetBuffTarget= 	// Choose which pets you want to affect. 
	"OnlyMyPets"    // If Player 1 casts the spell, it won't affect the pets Player 2 has. Enemies can also cast it and it will only affect their pets.
	"AllPlayerPets"	// This will buff pets of both players.
	"TargetsPets" 	// TargetsPets will affect the pets of all beings set as target, use this if you want to buff the pets of something On Hit.
	"AllEnemyPets" 	// Enemies generally do not have pets and should not be used without mods that give enemies pets.
	"NamedPetID"	// All Pets with a matching BeingID will be affected.

	PetID1="PetDragon"	//You can add as many PetIDs as you want to check.
	PetID2="PetKitty"	//Keep in mind if you have 2 Pet Kitty on the field, both will be affected
	PetID3="PetFox"		//This will also target Enemy Pets which have the ID, not just Player Pets.
	...
	PetID100="PetCustom"

	PetBuffStatus1=
	"Heal"   	// Several effects including Heal are also on the list. Heals the target.
	"DamageNorm" 	// Deals Damage not ignoring defense.
	"Damage" 	// Deals Damage ignoring defense.
	"DamageTrue" 	// Deals Damage ignoring defense and shields.
	"Invincibility" // Add invincibility.
	"CastSpell" 	// Forces the pet to cast a spell. The SpellID is PetBuffExtra1/2/3 etc.
	"Defense" 	// Any string that exists in the Status Enum will work. However, an invalid entry will break your spell.
	etc... 
	PetBuffStatus2="SpellPower"
	PetBuffStatus3="Flow"     	// You can set as many different status as you want. Identical entries will work but would be redundent.
	...		     	// It will not check PetBuffStatus5 if PetBuffStatus4 doesn't exist etc.
	PetBuffStatus100="Trinity"

	PetBuffAmount1="1"
	PetBuffAmount2="7"    	// If you do not set an amount it usually doesn't do anything.
	PetBuffAmount3="11"	
	....
	PetBuffAmount100="6"


	PetBuffDuration1="1"	// You do not need a duration for Heal. Durations are floats.
	PetBuffDuration2="0.1"  // Some buffs require a duration in order to have an effect but can be left out for those that do not. For example, Fragile does not need a duration and will ignore a duration but SpellPower requires a duration.
	PetBuffDuration3="10"	// If you leave out the duration for a status that requires it, the duration will be 9999 seconds.
	...
	PetBuffDuration100="2.3"

	PetBuffExtra1="None"	  // Extra is a field for only two things right now and is normally "None" and can be skipped
	PetBuffExtra2="StepSlash" // CastSpell requires Extra have a SpellID in it
	PetBuffExtra3="Cleanse"   // Cleanse when paired with a status effect will remove the status instead.
	...
	PetBuffExtra1="None"


	If you want to run this same system on an Artifact trigger, you'll need to write your own lua faction and run it by the artifact, and have that function run one of these function. 	//You can also run PetBuffSpell with an artifact but you'll need to set the correct Params in the artifact and you won't be able to change the effect between different Apps.

	PetBuffArtifactFunction(item, target, status, amount, duration, extra)		// Item needs to be a reference to the item that triggered this effect. 
	PetBuffArtifactPetIDFunction(item, petid, status, amount, duration, extra) 	// Targeting by PetID runs this function instead


	Examples
	-Give all pets 10 Defense for 10 seconds and all Pet Foxes 10 spellpower for 10 seconds triggered by an artifact-
	function MyPetBuffArtifact(item)
		PetBuffArtifactFunction(item, "OnlyMyPets", "Defense", 10, 10, "None")
		PetBuffArtifactPetIDFunction(item, "PetFox", "SpellPower", 10, 10, "None") 
	end
	-Make PetDragons cast Ring Of Fire when cast-
	<Params PetBuffTarget="NamedPetID" PetID1="PetDragon" PetBuffStatus1="CastSpell" PetBuffAmount1="0" PetBuffExtra1="RingOfFire"></Params>

	-Deal 10 damage and add 10 fragile to Enemy Pets-
	<Params PetBuffTarget="AllEnemyPets" PetBuffStatus1="Damage" PetBuffAmount1="10" PetBuffExtra1="Cleanse" PetBuffDuration1="10" PetBuffStatus2="Fragile" PetBuffAmount2="10"></Params>

	-Add 10 Spellpower for 10 seconds to the Caster's pets-
	<Params PetBuffTarget="OnlyMyPets" PetBuffStatus1="SpellPower" PetBuffAmount1="10" PetBuffDuration1="10"></Params>

	-Heal all Players' Pets by 10-
	<Params PetBuffTarget="AllPlayerPets" PetBuffStatus1="Heal" PetBuffAmount1="10"></Params>

	-Remove Frost, Fragile, and Poison from all Players' Pets-
	<Params PetBuffTarget="AllPlayerPets" PetBuffStatus1="Fragile" PetBuffExtra1="Cleanse" PetBuffStatus2="Frost" PetBuffExtra1="Cleanse" PetBuffStatus3="Poison" PetBuffExtra1="Cleanse"></Params>

[BOSSES]
	CustomBosses (/ DogeBoss) created by Shenanigans
	Edited, published, and currently supported by DecoyDoge

	MPL makes it easy to turn what would have been a custom standard enemy into a legitimate boss by adding a few XML elements to your being in Enemies.xml
	Primarily:

	<Tags>Boss</Tags>

	Note however, your boss' beingID should also start with "Boss", as the base game expects this in some places.
	Simply add the Boss tag to your enemy, and the game will treat it as a boss for all intents and purposes. 
	However, this will give your boss placeholder text lines, and it will continue its standard attack cycle even when the player is downed.
	Note that for the spare and mercy animations to display properly, your boss will need to have "_toIdle" and "_throw" animations defined in their _animInfo.xml.
	If your boss also has a "_spawn" animation, it will be played at the start of the fight.
	You can also use a few more XML elements to flesh out your boss. 
	
	The following are examples of each new element and their attributes.

	<Music introBoundary="5.3" endBoundary="234">BattleWithMyselfKokiRemix</Music>
	- Plays the track with the given name when the boss battle starts. You don't need to include the file format in the name, just ensure the format is supported.
	- The "introBoundary" and "endBoundary" are numbers of seconds between which, the track should loop. Useful for not replaying musical intro sequences.
	- You can only have one of this element

    <IntroLine>I'd hoped it wouldn't come to this...</IntroLine>
	- Animates the line at the start of the boss battle
	- Will play after your boss' "_spawn" animation, if they have one

    <ExecutionLine>I'll take good care of your soul.</ExecutionLine>
	- Animates the line before the boss executes the player (but after the pre-execution resolves, see below)

    <MercyLine>My vengeance isn't meant for you.</MercyLine>
	- Animates the line when the boss has mercy on the player

    <DownedLine>You just... got lucky...</DownedLine>
	- Animates the line while the boss is invincible after being defeated

    <FlawlessLine>I guess I didn't stand a chance...</FlawlessLine>
	- Same as the above, but only plays if the player didn't get hit for the whole fight

    <KilledLine>Sis-</KilledLine>
	- Quickly shows the line when the boss is executed from downed state

    <SparedLine>Another chance... I accept.</SparedLine>
	- Animates the line when the boss is spared

	Note: for all "Line" elements, you can define multiple, and one will be chosen at random. Furthermore, you can also specify a name to restrict the line to for character-specific lines using the "character" parameter:
	
	<IntroLine character="Saffron">Are you sure you're a real scientist?</IntroLine>

	If the player character's <Name> in Heroes.xml matches the text in the "character" parameter, lines for that character will be prioritized.

    <ExecutionSpell tile="2" preExecution="BossEffestaSpinScythe">LifeSword</ExecutionSpell>
	- Tells the boss what spell to use to execute the player. The spell should target the Player, or be guarenteed to hit from the chosen tile.
	- The "tile" attribute is optional and tells the boss how far in front of the player to stand before the execution. If omitted it will default to 4.
	- The "preExecution" attribute is optional an gives the boss a spell to cast before saying their execution line. Used for more intimidating execution animations.
	- Note if the execution spell misses, the boss will resume their regular attack loop.

    <DontCountKill/>
	- Prevents the boss' execution from counting towards pacifist / genocide endings
	- Useful if you want to make a spare-able mid-boss without affecting the run's outcome
	
[ASSISTS]
	Because Assists are linked to bosses in OSFE, you can also create custom assists for your custom bosses!
	All you need to do is create a being in Structures.xml that has a beingID of "[Your boss' name]Assist".
	So, for example, "BossEffesta", when spared, would look for a structure named "EffestaAssist" at the start of each fight to call as an assist.
	You can take the existing assists in Structures.xml as examples and modify them to suit your needs.

	You can also create assists that appear in the final cutscene of a Pacifist run. These assists follow the same format but also include an "F" at the end,
	such as "EffestaAssistF". Again, you can look at existing "AssistF" structures as reference.